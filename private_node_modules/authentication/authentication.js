'use strict'

	const jwt = require('jwt');
	const crypto = require('crypto');
	const bcrypt = require('bcrypt');
	const fs = require('fs');
	const nodemailer = require('nodemailer');

	const session_jwt_secret_filename = 'session_jwt_secret.txt';
	const session_jwt_secret = load_jwt_secret(session_jwt_secret_filename);
	const session_period = 3600*2; // time period that session token is valid for
	const session_refresh_grace_period = 1800; // Half-hour grace period for refreshing session.
	

	const change_password_jwt_secret_filename = 'change_password_jwt_secret.txt';
	const change_password_jwt_secret = load_jwt_secret(change_password_jwt_secret_filename);
	
	let salt_rounds = 12;


	async function create_new_user(data, members) {
		let result ={};

		var credentials = await members.collection('credentials');

		var items  = await credentials.find({emailaddress : data.emailaddress}).toArray();
		if (items.length > 0) {
			result.status='alreadyexists';
			result.session_token=null;
		
		}else {
			// if not, create new user in database and return status=success and a new session token
			// create a member-specific salt and hash the password
			let hash = await bcrypt.hash(data.password, salt_rounds);
			//store email, passwordhash in collection.
			await credentials.insertOne({'emailaddress': data.emailaddress, 'password': hash });
			result.status='success';
			result.session_token = get_new_session_token(data);				
			console.log('Created new member credentials'); 

		};
		return result;
	}

	async function login_user(data, members) {
		let result = {};
		let login_valid;

		// check email and password in database
		// if valid, return new session token and success status
		// if user not found or if password incorrect, return error status
		var credentials = await members.collection('credentials');
		let items  = await credentials.find({emailaddress : data.emailaddress}).toArray();
		if (items.length==1) {
			console.log('Found member credentials');			
			login_valid = await bcrypt.compare(data.password , items[0].password);
				if (login_valid) {

					result.status = 'success';
					result.session_token = get_new_session_token(data);				
					console.log('Logged in member');

				}else {
					console.log('Wrong password');
					result['status']='wrongpassword';

				}

		
		}else if(items.length==0){
			console.log('Member not found');
			result['status']='notfound';
			
		}else {
			console.log('More than one record found for member');
			result['status']='duplicaterecords';
	
		}		
	
		return result;

	}

	function get_new_session_token(data) {
		// returns a new session token
		var header = {"issuer" : "tamilpaadam.com", "type" : "jwt", "purpose" : "session"};
		var payload = {};

		payload['emailaddress'] = data.emailaddress;
		let d = new Date();
		let timestamp = Math.round(d.getTime()/1000); //number of seconds since 1/1/1970.
		payload['issuetime'] = timestamp;
		payload['expirytime'] = timestamp + session_period; // expires 2 hours after issue time.

		return jwt.generate_jwt(header, payload, session_jwt_secret);
				
	}

	function validate_session_token(token) {
		let result = {};
		// 1. verify signature
		// 2. extract data and check issuer, purpose and expiry time.
		let signature_valid = jwt.verify_signature(token, session_jwt_secret);
		
		if (signature_valid) {
			
			let token_data = jwt.extract_data_from_jwt(token);
			let header_valid = (token_data.header.issuer=="tamilpaadam.com") && (token_data.header.purpose=="session");
			if (header_valid) {

				let expirytime  = token_data.payload.expirytime;
				let d = new Date();
				let currenttime = Math.round(d.getTime()/1000);
				if (expirytime > currenttime) {
					result['valid'] = true;
					result['refresh'] = false;

				}else if ((currenttime-expirytime) <= session_refresh_grace_period){
					result['valid'] = false;
					result['refresh'] = true;
					result['new_session_token'] = get_new_session_token(token_data.payload);

				}

		}else {
			console.log('Header invalid');
			result['valid'] = false;
			result['refresh']  = false;

		}

		} else {
			console.log('Token signature invalid');
			result['valid'] = false;
			result['refresh']  = false;

		}
		return result;
	}

	async function change_password(data, params, members, tokens) {
		//data contains the new password
		//params contains the token
		let result = {};
			if (!params.token) {
				result['status'] = 'invalidtoken';
			} else {
				let token_valid_signature = jwt.verify_signature(params.token, change_password_jwt_secret);
				if (token_valid_signature) {
					let token_data = jwt.extract_data_from_jwt(params.token);
					let header_valid = (token_data.header.issuer=="tamilpaadam.com") && (token_data.header.purpose=="change_password");
					if (header_valid) {

					let expirytime  = token_data.payload.expirytime;
					let d = new Date();
					let currenttime = Math.round(d.getTime()/1000);
					if (expirytime > currenttime) {
						
						// check if token exists in token database"
						let tokens_in_database = await tokens.collection('change_password_tokens').find({'emailaddress' : token_data.payload.emailaddress, 'token' : params.token, 'used': false}).toArray();
						if (tokens_in_database.length!=1){

							result['status'] = 'tokennotfound';
						}else{

							// change password in database
								var credentials = await members.collection('credentials');
							// create a member-specific salt and hash the password
								await bcrypt.hash(data.password, salt_rounds, async (err, hash) => {
								//store email, passwordhash in collection.
								await credentials.updateOne({'emailaddress': token_data.payload.emailaddress}, { $set: {'password': hash }});


							});
							// set change password token as used=true.
							await tokens.collection('change_password_tokens').updateOne({'emailaddress': token_data.payload.emailaddress, 'token': params.token}, { $set: {'used': true }});
							result['status'] = 'success';
						}
					}

				}else {
					result['status'] = 'invalidtokenheader';
				}

			} else {
				result['status'] = 'invalidtokensignature';
			}
			
		}

		return result;
	}

	async function send_change_password_email(data, members, tokens) {

		let result = {};
		

		// First check if email is registered.  
		let member_credentials = await members.collection('credentials').find({'emailaddress' : data.emailaddress}).toArray();
		if (member_credentials.length==0) {
			result['status'] = 'notfound';

		}
		else if (member_credentials.length==1) {
			let change_attempt_ok = true;

			// Check tokens database to see if this email address has requested MORE than 3 reset password attempts in past 24 hours.
			let attempts = await tokens.collection('change_password_tokens').find({'emailaddress' : data.emailaddress}).toArray();
			if (attempts.length > 3) {

				// count the attempts in past 24 hours.
				let d = new Date();			
				let currenttime = Math.round(d.getTime()/1000);
				let n_attempts = 0;
				for (let a of attempts) {
					let a_token_data = jwt.extract_data_from_jwt(a.token);

					if ( (currenttime - a_token_data.payload.issuetime) < 24*3600) {
						n_attempts = n_attempts + 1;
					}
				}
				if (n_attempts > 3) {
					result['status'] = 'toomanyattempts';
					change_attempt_ok = false;
				}

			}

			// generate new token, add it to database and send email
			if (change_attempt_ok) {
				let change_password_token = get_new_change_password_token(data);
				// add token to database
				console.dir('data.emailaddress :');
				console.dir(data.emailaddress);
				await tokens.collection('change_password_tokens').insertOne({'emailaddress' : data.emailaddress, 'token' : change_password_token, 'used' : false});			
				// send email
				let dkim_key = await fs.readFileSync('tamilpaadam.private').toString();
				let email_body_html = '<html><body>Click on the link below to change your password at TamilPaadam.com. This link will expire in 1 hour.\n <br>' + '<a href=\'https://tamilpaadam.com/newpassword/' + change_password_token + '\'>Change Password</a></body></html>';
				let transporter = await nodemailer.createTransport({
					host: 'tamilpaadam.com',
					port: 25,
					secure: true,
					sendmail: true,
					newline: 'unix',
					path: '/usr/sbin/sendmail',
					dkim: {
						domainName: "tamilpaadam.com",
						keySelector: "202002",
						privateKey: dkim_key
					}

				});
				transporter.sendMail({ 
					from: 'support@tamilpaadam.com',
					to: data.emailaddress,
					subject: 'Change Password For TamilPaadam.com',
					html: email_body_html

					}, (err, info) => {
						console.log(info.envelope);
						console.log(info.messageId);
					});

				result['status'] = 'success';

			}

		} else if(member_credentials.length > 1) {
			result['status'] = 'duplicaterecords';
		}

		return result;

	}

	function get_new_change_password_token(data) {
		// returns a new session token
		var header = {"issuer" : "tamilpaadam.com", "type" : "jwt", "purpose" : "change_password"};
		var payload = {};

		payload['emailaddress'] = data.emailaddress;
		let d = new Date();
		let timestamp = Math.round(d.getTime()/1000); //number of seconds since 1/1/1970.
		payload['issuetime'] = timestamp;
		payload['expirytime'] = timestamp + 3600; // expires 1 hour after issue time.

		return jwt.generate_jwt(header, payload, change_password_jwt_secret);
			
	}


	function generate_new_random_session_jwt_secret() {
	
		let secret = crypto.randomBytes(256).toString('base64');
		fs.writeFileSync(session_jwt_secret_filename, secret);

	}

	function generate_new_random_change_password_jwt_secret() {
	
		let secret = crypto.randomBytes(256).toString('base64');
		fs.writeFileSync(change_password_jwt_secret_filename, secret);

	}


	// Load jwt secret from file
	function load_jwt_secret(filename){
		let s =  fs.readFileSync(filename, 'utf8');
		return s;
	}

	
	module.exports = { create_new_user , login_user, change_password, send_change_password_email, get_new_session_token, get_new_change_password_token, validate_session_token, generate_new_random_session_jwt_secret, generate_new_random_change_password_jwt_secret};

	
